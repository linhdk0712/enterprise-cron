@startuml Webhook Trigger Flow

title Webhook Trigger - Event-Driven Job Execution

actor "External System" as External
participant "API Server\n(Webhook Endpoint)" as API
participant "Webhook Validator" as Validator
participant "Rate Limiter" as RateLimit
participant "PostgreSQL\n(System DB)" as DB
participant "NATS JetStream" as NATS
participant "Worker Process" as Worker
participant "Job Context Manager" as ContextMgr
participant "MinIO" as MinIO

== Webhook Configuration ==

note over API, DB
  **Webhook Setup:**
  
  When job is created with webhook trigger enabled:
  1. Generate unique webhook URL
  2. Generate webhook secret key (for HMAC signature)
  3. Store in database
  
  Webhook URL format:
  https://api.example.com/webhooks/{webhook_id}
  
  Webhook secret: Used for HMAC-SHA256 signature validation
end note

== External System Triggers Job ==

External -> API: POST /webhooks/{webhook_id}\nX-Webhook-Signature: sha256=abc123...\nContent-Type: application/json\nBody: {\n  "event": "user.created",\n  "user_id": 12345,\n  "email": "newuser@example.com",\n  "timestamp": "2025-01-20T10:00:00Z"\n}
activate External
activate API

note over External
  **Webhook Request Headers:**
  X-Webhook-Signature: HMAC-SHA256 signature
  X-Webhook-Event: Event type (optional)
  X-Request-ID: Unique request ID (optional)
  Content-Type: application/json
end note

== Validate Webhook ==

API -> Validator: Validate webhook request
activate Validator

Validator -> DB: SELECT job_id, webhook_secret, enabled, rate_limit\nFROM jobs\nWHERE webhook_id = ?
activate DB
DB --> Validator: Job record:\n{\n  job_id: "550e8400-...",\n  webhook_secret: "secret_key_abc123",\n  enabled: true,\n  rate_limit: 100 per minute\n}
deactivate DB

alt Job not found
  Validator --> API: Error: Webhook not found
  API --> External: 404 Not Found\n{\n  "error": "Webhook not found",\n  "webhook_id": "{webhook_id}"\n}
  deactivate API
  deactivate External
  deactivate Validator
else Job disabled
  Validator --> API: Error: Job disabled
  API --> External: 403 Forbidden\n{\n  "error": "Job is disabled",\n  "job_id": "550e8400-..."\n}
  deactivate API
  deactivate External
  deactivate Validator
else Job enabled
  Validator -> Validator: Extract signature from header:\nX-Webhook-Signature: sha256=abc123...
  
  Validator -> Validator: Compute HMAC-SHA256:\nhmac = HMAC-SHA256(webhook_secret, request_body)\nexpected_signature = "sha256=" + hex(hmac)
  
  alt Signature invalid
    Validator --> API: Error: Invalid signature
    API --> External: 401 Unauthorized\n{\n  "error": "Invalid webhook signature"\n}
    deactivate API
    deactivate External
    deactivate Validator
  else Signature valid
    Validator --> API: Webhook validated
    deactivate Validator
  end
end

== Check Rate Limit ==

API -> RateLimit: Check rate limit for webhook_id
activate RateLimit

RateLimit -> RateLimit: Get request count from Redis:\nKEY: webhook:ratelimit:{webhook_id}\nTTL: 60 seconds

alt Rate limit exceeded
  RateLimit --> API: Rate limit exceeded
  API --> External: 429 Too Many Requests\n{\n  "error": "Rate limit exceeded",\n  "limit": 100,\n  "window": "1 minute",\n  "retry_after": 45\n}
  deactivate API
  deactivate External
  deactivate RateLimit
else Within rate limit
  RateLimit -> RateLimit: Increment counter in Redis:\nINCR webhook:ratelimit:{webhook_id}\nEXPIRE 60
  
  RateLimit --> API: Rate limit OK
  deactivate RateLimit
end

== Create Job Execution ==

API -> API: Generate execution_id and idempotency_key

API -> DB: INSERT INTO job_executions\n(id, job_id, idempotency_key, status, trigger_source, trigger_data)\nVALUES\n(execution_id, job_id, idem_key, 'Pending', 'webhook', webhook_payload)
activate DB
DB --> API: Execution created
deactivate DB

note over DB
  **Execution Record:**
  {
    "id": "exec-uuid",
    "job_id": "550e8400-...",
    "trigger_source": "webhook",
    "trigger_data": {
      "webhook_id": "webhook-123",
      "event": "user.created",
      "request_id": "req-456",
      "received_at": "2025-01-20T10:00:00Z"
    }
  }
end note

== Initialize Job Context with Webhook Data ==

API -> ContextMgr: Initialize Job Context with webhook data
activate ContextMgr

ContextMgr -> ContextMgr: Create context:\n{\n  "job_id": "550e8400-...",\n  "execution_id": "exec-uuid",\n  "trigger_source": "webhook",\n  "webhook": {\n    "payload": {\n      "event": "user.created",\n      "user_id": 12345,\n      "email": "newuser@example.com",\n      "timestamp": "2025-01-20T10:00:00Z"\n    },\n    "headers": {\n      "X-Webhook-Event": "user.created",\n      "X-Request-ID": "req-456"\n    },\n    "query_params": {},\n    "received_at": "2025-01-20T10:00:00Z"\n  },\n  "steps": {}\n}

ContextMgr -> MinIO: PUT jobs/{job_id}/executions/{exec_id}/context.json
activate MinIO
MinIO --> ContextMgr: Context stored
deactivate MinIO

ContextMgr --> API: Context initialized
deactivate ContextMgr

== Publish to Queue ==

API -> NATS: Publish job execution message\nSubject: jobs.execute\nPayload: {\n  job_id,\n  execution_id,\n  idempotency_key,\n  trigger_source: "webhook"\n}
activate NATS
NATS --> API: ACK (Message queued)
deactivate NATS

== Return Response to External System ==

API --> External: 202 Accepted\n{\n  "execution_id": "exec-uuid",\n  "status": "queued",\n  "message": "Job execution queued successfully",\n  "webhook_id": "webhook-123"\n}
deactivate API
deactivate External

note over External, API
  **202 Accepted Response:**
  - Job is queued, not yet executed
  - External system receives execution_id
  - Can poll for status using execution_id
  - Webhook returns immediately (non-blocking)
end note

== Worker Executes Job with Webhook Data ==

Worker -> NATS: Consume job message
activate Worker
activate NATS
NATS --> Worker: Job message
deactivate NATS

Worker -> MinIO: GET jobs/{job_id}/definition.json
activate MinIO
MinIO --> Worker: Job definition
deactivate MinIO

Worker -> MinIO: GET jobs/{job_id}/executions/{exec_id}/context.json
activate MinIO
MinIO --> Worker: Job Context (with webhook data)
deactivate MinIO

note over Worker
  **Job Definition Using Webhook Data:**
  {
    "steps": [
      {
        "id": "step1",
        "name": "process-new-user",
        "type": "DatabaseQuery",
        "config": {
          "query": "INSERT INTO user_events (user_id, email, event_type) VALUES ({{webhook.payload.user_id}}, '{{webhook.payload.email}}', '{{webhook.payload.event}}')"
        }
      },
      {
        "id": "step2",
        "name": "send-welcome-email",
        "type": "HttpRequest",
        "config": {
          "method": "POST",
          "url": "https://email-service.example.com/send",
          "body": {
            "to": "{{webhook.payload.email}}",
            "template": "welcome",
            "user_id": "{{webhook.payload.user_id}}"
          }
        }
      }
    ]
  }
end note

Worker -> Worker: Execute step1:\nResolve {{webhook.payload.user_id}} → 12345\nResolve {{webhook.payload.email}} → "newuser@example.com"\nResolve {{webhook.payload.event}} → "user.created"

Worker -> Worker: Execute database query with resolved values

Worker -> Worker: Execute step2:\nSend welcome email to newuser@example.com

Worker -> DB: UPDATE job_executions\nSET status = 'Success', completed_at = NOW()
activate DB
DB --> Worker: Updated
deactivate DB

Worker -> Worker: Emit metrics:\nwebhook_triggered_jobs_total{job_id, event_type}

deactivate Worker

== Query Execution Status ==

External -> API: GET /api/executions/{execution_id}
activate External
activate API

API -> DB: SELECT * FROM job_executions WHERE id = execution_id
activate DB
DB --> API: Execution record:\n{\n  "status": "Success",\n  "trigger_source": "webhook",\n  "completed_at": "2025-01-20T10:00:05Z"\n}
deactivate DB

API --> External: 200 OK\n{\n  "execution_id": "exec-uuid",\n  "job_id": "550e8400-...",\n  "status": "Success",\n  "trigger_source": "webhook",\n  "started_at": "2025-01-20T10:00:01Z",\n  "completed_at": "2025-01-20T10:00:05Z",\n  "duration_seconds": 4\n}
deactivate API
deactivate External

== Webhook URL Management ==

note over API, DB
  **Regenerate Webhook URL:**
  
  POST /api/jobs/{job_id}/webhook/regenerate
  
  1. Generate new webhook_id
  2. Generate new webhook_secret
  3. Update database
  4. Invalidate old webhook URL
  5. Return new webhook URL and secret
  
  **Response:**
  {
    "webhook_url": "https://api.example.com/webhooks/{new_webhook_id}",
    "webhook_secret": "new_secret_key_xyz789",
    "previous_webhook_invalidated": true
  }
  
  **Use Cases:**
  - Secret key compromised
  - Security rotation policy
  - Webhook URL leaked
end note

== Webhook Signature Verification ==

note over Validator
  **HMAC-SHA256 Signature Verification:**
  
  1. Extract signature from header:
     X-Webhook-Signature: sha256=abc123...
  
  2. Compute expected signature:
     ```rust
     use hmac::{Hmac, Mac};
     use sha2::Sha256;
     
     type HmacSha256 = Hmac<Sha256>;
     
     let mut mac = HmacSha256::new_from_slice(webhook_secret.as_bytes())?;
     mac.update(request_body.as_bytes());
     let result = mac.finalize();
     let expected = format!("sha256={}", hex::encode(result.into_bytes()));
     ```
  
  3. Compare signatures (constant-time comparison):
     ```rust
     use subtle::ConstantTimeEq;
     
     if received_signature.as_bytes().ct_eq(expected.as_bytes()).into() {
         // Valid signature
     } else {
         // Invalid signature
     }
     ```
  
  **Security Benefits:**
  - Prevents replay attacks (with timestamp validation)
  - Ensures request authenticity
  - Protects against man-in-the-middle attacks
end note

== Rate Limiting Strategy ==

note over RateLimit
  **Rate Limit Implementation (Redis):**
  
  **Sliding Window Counter:**
  ```rust
  let key = format!("webhook:ratelimit:{}", webhook_id);
  let count: i64 = redis.incr(&key).await?;
  
  if count == 1 {
      redis.expire(&key, 60).await?; // 60 seconds window
  }
  
  if count > rate_limit {
      return Err(RateLimitExceeded);
  }
  ```
  
  **Configuration per Job:**
  - Default: 100 requests per minute
  - Configurable: 10 to 10,000 per minute
  - Burst allowance: 2x limit for short bursts
  
  **Response Headers:**
  X-RateLimit-Limit: 100
  X-RateLimit-Remaining: 45
  X-RateLimit-Reset: 1737369600
  
  **Benefits:**
  - Prevents webhook abuse
  - Protects system from DDoS
  - Fair resource allocation
end note

== Concurrent Execution Control ==

note over API, DB
  **Prevent Concurrent Execution:**
  
  If job configured with:
  {
    "concurrent_execution": false
  }
  
  **Check before queueing:**
  ```sql
  SELECT COUNT(*) FROM job_executions
  WHERE job_id = ? 
  AND status IN ('Pending', 'Running')
  ```
  
  If count > 0:
  - Return 409 Conflict
  - Message: "Job execution already in progress"
  - Include running execution_id in response
  
  **Use Cases:**
  - Jobs that modify shared resources
  - Jobs with exclusive locks
  - Jobs that must run sequentially
end note

== Webhook Event Types ==

note over External, API
  **Common Webhook Events:**
  
  **User Events:**
  - user.created
  - user.updated
  - user.deleted
  
  **Order Events:**
  - order.placed
  - order.paid
  - order.shipped
  - order.completed
  
  **Payment Events:**
  - payment.received
  - payment.failed
  - payment.refunded
  
  **System Events:**
  - data.sync.required
  - report.generate
  - backup.trigger
  
  **Custom Events:**
  - Any custom event type defined by external system
  
  Event type can be used for:
  - Routing to different jobs
  - Conditional logic in job steps
  - Filtering and monitoring
end note

@enduml
